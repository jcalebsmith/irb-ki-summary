[
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01V5JtrMV9trZS2KXwCy4ZSq",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/storage/referenceManager.ts"
        }
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01XfnA6jgJ6RXi8UdTFyNuvh",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/storage/qualityMetrics.ts"
        }
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01V5JtrMV9trZS2KXwCy4ZSq",
        "type": "tool_result",
        "content": "     1→/**\n     2→ * ReferenceManager - Centralized reference tracking and citation management\n     3→ * \n     4→ * This class manages all sources and references throughout the research pipeline,\n     5→ * providing global citation numbering, deduplication, and rich metadata tracking.\n     6→ * \n     7→ * Follows Mastra conventions with singleton pattern for global access.\n     8→ */\n     9→\n    10→export interface ReferenceMetadata {\n    11→  url: string;\n    12→  title: string;\n    13→  snippet?: string;\n    14→  content?: string;\n    15→  confidence?: number;\n    16→  publishedDate?: string;\n    17→  author?: string;\n    18→  sourceType?: 'web' | 'academic' | 'news' | 'documentation' | 'other';\n    19→  accessedAt: string;\n    20→  agentName?: string;\n    21→  queryUsed?: string;\n    22→}\n    23→\n    24→export interface Reference {\n    25→  id: string;                  // Unique identifier (hash of URL)\n    26→  citationKey: string;         // e.g., \"[1]\", \"[2]\", etc.\n    27→  globalNumber: number;        // Global citation number\n    28→  metadata: ReferenceMetadata;\n    29→  usedInSections: Set<string>; // Track which sections use this reference\n    30→  citationCount: number;       // How many times this reference has been cited\n    31→}\n    32→\n    33→export interface CitationContext {\n    34→  referenceId: string;\n    35→  citationKey: string;\n    36→  context: string;             // The text surrounding the citation\n    37→  confidence: number;          // Confidence in this specific citation\n    38→  sectionName?: string;\n    39→}\n    40→\n    41→export class ReferenceManager {\n    42→  private references: Map<string, Reference>;\n    43→  private urlToId: Map<string, string>;\n    44→  private nextCitationNumber: number;\n    45→  private citationContexts: Map<string, CitationContext[]>;\n    46→\n    47→  constructor() {\n    48→    this.references = new Map();\n    49→    this.urlToId = new Map();\n    50→    this.nextCitationNumber = 1;\n    51→    this.citationContexts = new Map();\n    52→  }\n    53→\n    54→  /**\n    55→   * Add a new reference or update existing one\n    56→   * Returns the citation key for the reference\n    57→   */\n    58→  addReference(metadata: ReferenceMetadata, sectionName?: string): string {\n    59→    // Check if reference already exists by URL\n    60→    const existingId = this.urlToId.get(metadata.url);\n    61→    \n    62→    if (existingId) {\n    63→      // Update existing reference\n    64→      const ref = this.references.get(existingId)!;\n    65→      \n    66→      // Update metadata with new information if provided\n    67→      if (metadata.snippet && !ref.metadata.snippet) {\n    68→        ref.metadata.snippet = metadata.snippet;\n    69→      }\n    70→      if (metadata.confidence !== undefined) {\n    71→        // Update confidence if new value is higher or if no previous confidence\n    72→        if (!ref.metadata.confidence || metadata.confidence > ref.metadata.confidence) {\n    73→          ref.metadata.confidence = metadata.confidence;\n    74→        }\n    75→      }\n    76→      if (metadata.content && (!ref.metadata.content || metadata.content.length > ref.metadata.content.length)) {\n    77→        ref.metadata.content = metadata.content;\n    78→      }\n    79→      if (metadata.publishedDate && !ref.metadata.publishedDate) {\n    80→        ref.metadata.publishedDate = metadata.publishedDate;\n    81→      }\n    82→      if (metadata.author && !ref.metadata.author) {\n    83→        ref.metadata.author = metadata.author;\n    84→      }\n    85→      if (metadata.sourceType && !ref.metadata.sourceType) {\n    86→        ref.metadata.sourceType = metadata.sourceType;\n    87→      }\n    88→      \n    89→      // Track section usage\n    90→      if (sectionName) {\n    91→        ref.usedInSections.add(sectionName);\n    92→      }\n    93→      \n    94→      ref.citationCount++;\n    95→      \n    96→      return ref.citationKey;\n    97→    }\n    98→\n    99→    // Create new reference\n   100→    const id = this.generateId(metadata.url);\n   101→    const citationKey = `[${this.nextCitationNumber}]`;\n   102→    \n   103→    const newReference: Reference = {\n   104→      id,\n   105→      citationKey,\n   106→      globalNumber: this.nextCitationNumber,\n   107→      metadata: {\n   108→        ...metadata,\n   109→        accessedAt: metadata.accessedAt || new Date().toISOString()\n   110→      },\n   111→      usedInSections: new Set(sectionName ? [sectionName] : []),\n   112→      citationCount: 1\n   113→    };\n   114→\n   115→    this.references.set(id, newReference);\n   116→    this.urlToId.set(metadata.url, id);\n   117→    this.nextCitationNumber++;\n   118→\n   119→    return citationKey;\n   120→  }\n   121→\n   122→  /**\n   123→   * Add citation context for better evidence tracking\n   124→   */\n   125→  addCitationContext(\n   126→    referenceUrl: string, \n   127→    context: string, \n   128→    confidence: number, \n   129→    sectionName?: string\n   130→  ): void {\n   131→    const id = this.urlToId.get(referenceUrl);\n   132→    if (!id) return;\n   133→\n   134→    const ref = this.references.get(id);\n   135→    if (!ref) return;\n   136→\n   137→    const citationContext: CitationContext = {\n   138→      referenceId: id,\n   139→      citationKey: ref.citationKey,\n   140→      context,\n   141→      confidence,\n   142→      sectionName\n   143→    };\n   144→\n   145→    if (!this.citationContexts.has(id)) {\n   146→      this.citationContexts.set(id, []);\n   147→    }\n   148→    \n   149→    this.citationContexts.get(id)!.push(citationContext);\n   150→  }\n   151→\n   152→  /**\n   153→   * Get citation key for a URL\n   154→   */\n   155→  getCitationKey(url: string): string | null {\n   156→    const id = this.urlToId.get(url);\n   157→    if (!id) return null;\n   158→    \n   159→    const ref = this.references.get(id);\n   160→    return ref ? ref.citationKey : null;\n   161→  }\n   162→\n   163→  /**\n   164→   * Get reference by citation key\n   165→   */\n   166→  getReferenceByCitationKey(citationKey: string): Reference | null {\n   167→    for (const ref of this.references.values()) {\n   168→      if (ref.citationKey === citationKey) {\n   169→        return ref;\n   170→      }\n   171→    }\n   172→    return null;\n   173→  }\n   174→\n   175→  /**\n   176→   * Get reference by URL\n   177→   */\n   178→  getReferenceByUrl(url: string): Reference | null {\n   179→    const id = this.urlToId.get(url);\n   180→    if (!id) return null;\n   181→    return this.references.get(id) || null;\n   182→  }\n   183→\n   184→  /**\n   185→   * Get all references for a specific section\n   186→   */\n   187→  getReferencesForSection(sectionName: string): Reference[] {\n   188→    const sectionRefs: Reference[] = [];\n   189→    \n   190→    for (const ref of this.references.values()) {\n   191→      if (ref.usedInSections.has(sectionName)) {\n   192→        sectionRefs.push(ref);\n   193→      }\n   194→    }\n   195→    \n   196→    // Sort by global number\n   197→    return sectionRefs.sort((a, b) => a.globalNumber - b.globalNumber);\n   198→  }\n   199→\n   200→  /**\n   201→   * Get all references sorted by citation number\n   202→   */\n   203→  getAllReferences(): Reference[] {\n   204→    return Array.from(this.references.values())\n   205→      .sort((a, b) => a.globalNumber - b.globalNumber);\n   206→  }\n   207→\n   208→  /**\n   209→   * Get high-confidence references (confidence >= threshold)\n   210→   */\n   211→  getHighConfidenceReferences(threshold: number = 0.7): Reference[] {\n   212→    return Array.from(this.references.values())\n   213→      .filter(ref => (ref.metadata.confidence || 0) >= threshold)\n   214→      .sort((a, b) => (b.metadata.confidence || 0) - (a.metadata.confidence || 0));\n   215→  }\n   216→\n   217→  /**\n   218→   * Format references for inclusion in report\n   219→   */\n   220→  formatReferencesSection(): string {\n   221→    const references = this.getAllReferences();\n   222→    \n   223→    if (references.length === 0) {\n   224→      return '';\n   225→    }\n   226→\n   227→    let referencesSection = '## References\\n\\n';\n   228→    \n   229→    for (const ref of references) {\n   230→      const { citationKey, metadata } = ref;\n   231→      const { title, url, author, publishedDate, sourceType } = metadata;\n   232→      \n   233→      // Format: [1] Title. Author. Date. URL. (Source Type)\n   234→      let citation = `${citationKey} `;\n   235→      \n   236→      if (title) {\n   237→        citation += `${title}. `;\n   238→      }\n   239→      \n   240→      if (author) {\n   241→        citation += `${author}. `;\n   242→      }\n   243→      \n   244→      if (publishedDate) {\n   245→        citation += `${publishedDate}. `;\n   246→      }\n   247→      \n   248→      citation += url;\n   249→      \n   250→      if (sourceType && sourceType !== 'other') {\n   251→        citation += ` (${sourceType})`;\n   252→      }\n   253→      \n   254→      referencesSection += citation + '\\n\\n';\n   255→    }\n   256→    \n   257→    return referencesSection;\n   258→  }\n   259→\n   260→  /**\n   261→   * Replace URLs in text with citation keys\n   262→   */\n   263→  replaceUrlsWithCitations(text: string): string {\n   264→    let processedText = text;\n   265→    \n   266→    // Find all URLs in the text\n   267→    const urlRegex = /(https?:\\/\\/[^\\s\\)]+)/g;\n   268→    const urls = text.match(urlRegex) || [];\n   269→    \n   270→    for (const url of urls) {\n   271→      const citationKey = this.getCitationKey(url);\n   272→      if (citationKey) {\n   273→        // Replace URL with citation key\n   274→        processedText = processedText.replace(url, citationKey);\n   275→      }\n   276→    }\n   277→    \n   278→    return processedText;\n   279→  }\n   280→\n   281→  /**\n   282→   * Get citation contexts for evidence tracking\n   283→   */\n   284→  getCitationContexts(referenceId: string): CitationContext[] {\n   285→    return this.citationContexts.get(referenceId) || [];\n   286→  }\n   287→\n   288→  /**\n   289→   * Generate statistics about references\n   290→   */\n   291→  getStatistics() {\n   292→    const totalReferences = this.references.size;\n   293→    const referencesWithHighConfidence = this.getHighConfidenceReferences(0.8).length;\n   294→    const averageConfidence = this.calculateAverageConfidence();\n   295→    const sectionsUsingReferences = this.getSectionsUsingReferences();\n   296→    const mostCitedReferences = this.getMostCitedReferences(5);\n   297→    const averageCitationsPerReference = this.calculateAverageCitations();\n   298→    \n   299→    return {\n   300→      totalReferences,\n   301→      referencesWithHighConfidence,\n   302→      averageConfidence,\n   303→      sectionsCount: sectionsUsingReferences.size,\n   304→      mostCitedReferences: mostCitedReferences.map(ref => ({\n   305→        url: ref.metadata.url,\n   306→        title: ref.metadata.title,\n   307→        citationKey: ref.citationKey,\n   308→        citationCount: ref.citationCount\n   309→      })),\n   310→      averageCitationsPerReference\n   311→    };\n   312→  }\n   313→\n   314→  /**\n   315→   * Clear all references (use with caution)\n   316→   */\n   317→  clear(): void {\n   318→    this.references.clear();\n   319→    this.urlToId.clear();\n   320→    this.citationContexts.clear();\n   321→    this.nextCitationNumber = 1;\n   322→  }\n   323→\n   324→  /**\n   325→   * Export references as JSON for persistence\n   326→   */\n   327→  exportToJSON(): string {\n   328→    const exportData = {\n   329→      references: Array.from(this.references.entries()).map(([id, ref]) => ({\n   330→        id,\n   331→        ...ref,\n   332→        usedInSections: Array.from(ref.usedInSections)\n   333→      })),\n   334→      citationContexts: Array.from(this.citationContexts.entries()),\n   335→      nextCitationNumber: this.nextCitationNumber\n   336→    };\n   337→    \n   338→    return JSON.stringify(exportData, null, 2);\n   339→  }\n   340→\n   341→  /**\n   342→   * Import references from JSON\n   343→   */\n   344→  importFromJSON(json: string): void {\n   345→    try {\n   346→      const data = JSON.parse(json);\n   347→      \n   348→      this.clear();\n   349→      \n   350→      // Restore references\n   351→      for (const refData of data.references) {\n   352→        const ref: Reference = {\n   353→          ...refData,\n   354→          usedInSections: new Set(refData.usedInSections)\n   355→        };\n   356→        this.references.set(ref.id, ref);\n   357→        this.urlToId.set(ref.metadata.url, ref.id);\n   358→      }\n   359→      \n   360→      // Restore citation contexts\n   361→      for (const [id, contexts] of data.citationContexts) {\n   362→        this.citationContexts.set(id, contexts);\n   363→      }\n   364→      \n   365→      this.nextCitationNumber = data.nextCitationNumber;\n   366→    } catch (error) {\n   367→      console.error('Failed to import references from JSON:', error);\n   368→      throw error;\n   369→    }\n   370→  }\n   371→\n   372→  // Private helper methods\n   373→  \n   374→  private generateId(url: string): string {\n   375→    // Simple hash function for URL to ID\n   376→    let hash = 0;\n   377→    for (let i = 0; i < url.length; i++) {\n   378→      const char = url.charCodeAt(i);\n   379→      hash = ((hash << 5) - hash) + char;\n   380→      hash = hash & hash; // Convert to 32bit integer\n   381→    }\n   382→    return `ref_${Math.abs(hash).toString(16)}`;\n   383→  }\n   384→\n   385→  private calculateAverageConfidence(): number {\n   386→    const confidences = Array.from(this.references.values())\n   387→      .map(ref => ref.metadata.confidence)\n   388→      .filter((conf): conf is number => conf !== undefined && conf > 0);\n   389→    \n   390→    if (confidences.length === 0) return 0;\n   391→    \n   392→    return confidences.reduce((sum, conf) => sum + conf, 0) / confidences.length;\n   393→  }\n   394→\n   395→  private calculateAverageCitations(): number {\n   396→    if (this.references.size === 0) return 0;\n   397→    \n   398→    const totalCitations = Array.from(this.references.values())\n   399→      .reduce((sum, ref) => sum + ref.citationCount, 0);\n   400→    \n   401→    return totalCitations / this.references.size;\n   402→  }\n   403→\n   404→  private getSectionsUsingReferences(): Set<string> {\n   405→    const sections = new Set<string>();\n   406→    \n   407→    for (const ref of this.references.values()) {\n   408→      for (const section of ref.usedInSections) {\n   409→        sections.add(section);\n   410→      }\n   411→    }\n   412→    \n   413→    return sections;\n   414→  }\n   415→\n   416→  private getMostCitedReferences(limit: number): Reference[] {\n   417→    return Array.from(this.references.values())\n   418→      .sort((a, b) => b.citationCount - a.citationCount)\n   419→      .slice(0, limit);\n   420→  }\n   421→}\n   422→\n   423→// Export singleton instance following Mastra pattern\n   424→export const referenceManager = new ReferenceManager();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01XfnA6jgJ6RXi8UdTFyNuvh",
        "type": "tool_result",
        "content": "     1→/**\n     2→ * QualityMetrics - Multi-dimensional quality assessment framework\n     3→ * \n     4→ * Provides comprehensive quality evaluation for research findings,\n     5→ * integrating with ReferenceManager for source quality assessment.\n     6→ * \n     7→ * Based on techniques from reference-syntheos-deep-research framework.\n     8→ */\n     9→\n    10→import { referenceManager, Reference } from './referenceManager';\n    11→\n    12→export interface QualityDimensions {\n    13→  completeness: number;      // 0-100: Coverage of research query aspects\n    14→  accuracy: number;          // 0-100: Confidence in information accuracy\n    15→  relevance: number;         // 0-100: Relevance to original query\n    16→  sourceQuality: number;     // 0-100: Quality and authority of sources\n    17→  depth: number;             // 0-100: Depth of analysis\n    18→  coherence: number;         // 0-100: Internal consistency\n    19→}\n    20→\n    21→export interface QualityThresholds {\n    22→  overall: number;           // Overall quality threshold (default: 75)\n    23→  completeness: number;      // Minimum completeness (default: 70)\n    24→  accuracy: number;          // Minimum accuracy (default: 80)\n    25→  relevance: number;         // Minimum relevance (default: 75)\n    26→  sourceQuality: number;     // Minimum source quality (default: 70)\n    27→  depth: number;             // Minimum depth (default: 60)\n    28→  coherence: number;         // Minimum coherence (default: 70)\n    29→  minimumSources: number;    // Minimum number of sources (default: 5)\n    30→}\n    31→\n    32→export interface SectionMetadata {\n    33→  sectionName: string;\n    34→  timestamp: string;\n    35→  qualityScores: QualityDimensions;\n    36→  overallScore: number;\n    37→  meetsThresholds: boolean;\n    38→  sourceCount: number;\n    39→  averageConfidence: number;\n    40→  insightCount: number;\n    41→  citationKeys: string[];\n    42→  improvementRecommendations: string[];\n    43→}\n    44→\n    45→export interface ResearchQualityReport {\n    46→  overallQuality: QualityDimensions;\n    47→  overallScore: number;\n    48→  meetsRequirements: boolean;\n    49→  sections: SectionMetadata[];\n    50→  totalSources: number;\n    51→  highConfidenceSources: number;\n    52→  averageSourceConfidence: number;\n    53→  improvementPriorities: ImprovementPriority[];\n    54→  iterationRecommendation: 'continue' | 'complete' | 'review';\n    55→}\n    56→\n    57→export interface ImprovementPriority {\n    58→  dimension: keyof QualityDimensions;\n    59→  currentScore: number;\n    60→  targetScore: number;\n    61→  priority: 'critical' | 'high' | 'medium' | 'low';\n    62→  recommendations: string[];\n    63→}\n    64→\n    65→export class QualityMetrics {\n    66→  private thresholds: QualityThresholds;\n    67→  private sectionMetadata: Map<string, SectionMetadata>;\n    68→  \n    69→  constructor(customThresholds?: Partial<QualityThresholds>) {\n    70→    this.thresholds = {\n    71→      overall: 75,\n    72→      completeness: 70,\n    73→      accuracy: 80,\n    74→      relevance: 75,\n    75→      sourceQuality: 70,\n    76→      depth: 60,\n    77→      coherence: 70,\n    78→      minimumSources: 5,\n    79→      ...customThresholds\n    80→    };\n    81→    this.sectionMetadata = new Map();\n    82→  }\n    83→\n    84→  /**\n    85→   * Assess quality of research findings\n    86→   */\n    87→  assessResearchQuality(\n    88→    findings: Array<{ content: string; confidence?: number; sources?: string[] }>,\n    89→    originalQuery: string,\n    90→    requiredTopics: string[] = []\n    91→  ): QualityDimensions {\n    92→    const references = referenceManager.getAllReferences();\n    93→    \n    94→    // Calculate completeness based on topic coverage\n    95→    const completeness = this.calculateCompleteness(findings, requiredTopics, originalQuery);\n    96→    \n    97→    // Calculate accuracy based on confidence scores\n    98→    const accuracy = this.calculateAccuracy(findings, references);\n    99→    \n   100→    // Calculate relevance to original query\n   101→    const relevance = this.calculateRelevance(findings, originalQuery);\n   102→    \n   103→    // Calculate source quality\n   104→    const sourceQuality = this.calculateSourceQuality(references);\n   105→    \n   106→    // Calculate depth of analysis\n   107→    const depth = this.calculateDepth(findings, references);\n   108→    \n   109→    // Calculate coherence (internal consistency)\n   110→    const coherence = this.calculateCoherence(findings);\n   111→    \n   112→    return {\n   113→      completeness,\n   114→      accuracy,\n   115→      relevance,\n   116→      sourceQuality,\n   117→      depth,\n   118→      coherence\n   119→    };\n   120→  }\n   121→\n   122→  /**\n   123→   * Evaluate if quality meets thresholds\n   124→   */\n   125→  meetsQualityThresholds(dimensions: QualityDimensions): boolean {\n   126→    const overallScore = this.calculateOverallScore(dimensions);\n   127→    \n   128→    return (\n   129→      overallScore >= this.thresholds.overall &&\n   130→      dimensions.completeness >= this.thresholds.completeness &&\n   131→      dimensions.accuracy >= this.thresholds.accuracy &&\n   132→      dimensions.relevance >= this.thresholds.relevance &&\n   133→      dimensions.sourceQuality >= this.thresholds.sourceQuality &&\n   134→      dimensions.depth >= this.thresholds.depth &&\n   135→      dimensions.coherence >= this.thresholds.coherence\n   136→    );\n   137→  }\n   138→\n   139→  /**\n   140→   * Calculate overall quality score\n   141→   */\n   142→  calculateOverallScore(dimensions: QualityDimensions): number {\n   143→    // Weighted average with emphasis on accuracy and relevance\n   144→    const weights = {\n   145→      completeness: 0.15,\n   146→      accuracy: 0.25,\n   147→      relevance: 0.20,\n   148→      sourceQuality: 0.15,\n   149→      depth: 0.15,\n   150→      coherence: 0.10\n   151→    };\n   152→    \n   153→    return Object.entries(dimensions).reduce((score, [key, value]) => {\n   154→      return score + (value * weights[key as keyof QualityDimensions]);\n   155→    }, 0);\n   156→  }\n   157→\n   158→  /**\n   159→   * Generate improvement recommendations\n   160→   */\n   161→  generateImprovementRecommendations(\n   162→    dimensions: QualityDimensions\n   163→  ): ImprovementPriority[] {\n   164→    const priorities: ImprovementPriority[] = [];\n   165→    \n   166→    for (const [dimension, score] of Object.entries(dimensions)) {\n   167→      const threshold = this.thresholds[dimension as keyof QualityDimensions];\n   168→      if (typeof threshold === 'number' && score < threshold) {\n   169→        const gap = threshold - score;\n   170→        const priority = this.getPriority(gap);\n   171→        \n   172→        priorities.push({\n   173→          dimension: dimension as keyof QualityDimensions,\n   174→          currentScore: score,\n   175→          targetScore: threshold,\n   176→          priority,\n   177→          recommendations: this.getRecommendations(dimension as keyof QualityDimensions, score)\n   178→        });\n   179→      }\n   180→    }\n   181→    \n   182→    // Sort by priority\n   183→    return priorities.sort((a, b) => {\n   184→      const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n   185→      return priorityOrder[a.priority] - priorityOrder[b.priority];\n   186→    });\n   187→  }\n   188→\n   189→  /**\n   190→   * Track section-level quality metadata\n   191→   */\n   192→  addSectionMetadata(\n   193→    sectionName: string,\n   194→    findings: Array<{ content: string; confidence?: number; sources?: string[] }>,\n   195→    originalQuery: string\n   196→  ): SectionMetadata {\n   197→    const qualityScores = this.assessResearchQuality(findings, originalQuery);\n   198→    const overallScore = this.calculateOverallScore(qualityScores);\n   199→    const references = referenceManager.getReferencesForSection(sectionName);\n   200→    \n   201→    const metadata: SectionMetadata = {\n   202→      sectionName,\n   203→      timestamp: new Date().toISOString(),\n   204→      qualityScores,\n   205→      overallScore,\n   206→      meetsThresholds: this.meetsQualityThresholds(qualityScores),\n   207→      sourceCount: references.length,\n   208→      averageConfidence: this.calculateAverageConfidence(findings),\n   209→      insightCount: findings.length,\n   210→      citationKeys: references.map(r => r.citationKey),\n   211→      improvementRecommendations: this.generateImprovementRecommendations(qualityScores)\n   212→        .map(p => p.recommendations)\n   213→        .flat()\n   214→    };\n   215→    \n   216→    this.sectionMetadata.set(sectionName, metadata);\n   217→    return metadata;\n   218→  }\n   219→\n   220→  /**\n   221→   * Generate comprehensive quality report\n   222→   */\n   223→  generateQualityReport(): ResearchQualityReport {\n   224→    const allSections = Array.from(this.sectionMetadata.values());\n   225→    const allReferences = referenceManager.getAllReferences();\n   226→    const stats = referenceManager.getStatistics();\n   227→    \n   228→    // Calculate overall quality across all sections\n   229→    const overallQuality = this.aggregateQualityDimensions(allSections);\n   230→    const overallScore = this.calculateOverallScore(overallQuality);\n   231→    const meetsRequirements = this.meetsQualityThresholds(overallQuality);\n   232→    \n   233→    // Determine iteration recommendation\n   234→    let iterationRecommendation: 'continue' | 'complete' | 'review' = 'complete';\n   235→    if (!meetsRequirements) {\n   236→      if (overallScore < 50) {\n   237→        iterationRecommendation = 'continue'; // Need more research\n   238→      } else {\n   239→        iterationRecommendation = 'review'; // Close to threshold, needs review\n   240→      }\n   241→    }\n   242→    \n   243→    return {\n   244→      overallQuality,\n   245→      overallScore,\n   246→      meetsRequirements,\n   247→      sections: allSections,\n   248→      totalSources: stats.totalReferences,\n   249→      highConfidenceSources: stats.referencesWithHighConfidence,\n   250→      averageSourceConfidence: stats.averageConfidence,\n   251→      improvementPriorities: this.generateImprovementRecommendations(overallQuality),\n   252→      iterationRecommendation\n   253→    };\n   254→  }\n   255→\n   256→  /**\n   257→   * Determine if additional research iterations are needed\n   258→   */\n   259→  shouldContinueResearch(currentIteration: number, maxIterations: number): boolean {\n   260→    const report = this.generateQualityReport();\n   261→    \n   262→    // Stop if max iterations reached\n   263→    if (currentIteration >= maxIterations) {\n   264→      return false;\n   265→    }\n   266→    \n   267→    // Continue if quality requirements not met and recommendation is to continue\n   268→    if (!report.meetsRequirements && report.iterationRecommendation === 'continue') {\n   269→      return true;\n   270→    }\n   271→    \n   272→    // Check for critical gaps\n   273→    const hasCriticalGaps = report.improvementPriorities.some(p => p.priority === 'critical');\n   274→    if (hasCriticalGaps && currentIteration < maxIterations - 1) {\n   275→      return true;\n   276→    }\n   277→    \n   278→    // Check minimum source requirement\n   279→    if (report.totalSources < this.thresholds.minimumSources) {\n   280→      return true;\n   281→    }\n   282→    \n   283→    return false;\n   284→  }\n   285→\n   286→  // Private helper methods\n   287→\n   288→  private calculateCompleteness(\n   289→    findings: Array<{ content: string }>,\n   290→    requiredTopics: string[],\n   291→    query: string\n   292→  ): number {\n   293→    if (requiredTopics.length === 0) {\n   294→      // Base completeness on finding count and content length\n   295→      const targetFindings = 10;\n   296→      const findingScore = Math.min(100, (findings.length / targetFindings) * 100);\n   297→      const contentScore = findings.length > 0 \n   298→        ? Math.min(100, (findings.reduce((sum, f) => sum + f.content.length, 0) / 5000) * 100)\n   299→        : 0;\n   300→      return (findingScore + contentScore) / 2;\n   301→    }\n   302→    \n   303→    // Check topic coverage\n   304→    const coveredTopics = requiredTopics.filter(topic => \n   305→      findings.some(f => f.content.toLowerCase().includes(topic.toLowerCase()))\n   306→    );\n   307→    \n   308→    return (coveredTopics.length / requiredTopics.length) * 100;\n   309→  }\n   310→\n   311→  private calculateAccuracy(\n   312→    findings: Array<{ confidence?: number }>,\n   313→    references: Reference[]\n   314→  ): number {\n   315→    // Average confidence from findings\n   316→    const findingConfidences = findings\n   317→      .map(f => f.confidence)\n   318→      .filter((c): c is number => c !== undefined);\n   319→    \n   320→    const avgFindingConfidence = findingConfidences.length > 0\n   321→      ? findingConfidences.reduce((sum, c) => sum + c, 0) / findingConfidences.length\n   322→      : 0.5;\n   323→    \n   324→    // Average confidence from references\n   325→    const refConfidences = references\n   326→      .map(r => r.metadata.confidence)\n   327→      .filter((c): c is number => c !== undefined);\n   328→    \n   329→    const avgRefConfidence = refConfidences.length > 0\n   330→      ? refConfidences.reduce((sum, c) => sum + c, 0) / refConfidences.length\n   331→      : 0.5;\n   332→    \n   333→    // Combine both scores\n   334→    return ((avgFindingConfidence + avgRefConfidence) / 2) * 100;\n   335→  }\n   336→\n   337→  private calculateRelevance(\n   338→    findings: Array<{ content: string }>,\n   339→    query: string\n   340→  ): number {\n   341→    const queryTerms = query.toLowerCase().split(/\\s+/)\n   342→      .filter(term => term.length > 3);\n   343→    \n   344→    if (queryTerms.length === 0) return 75; // Default relevance\n   345→    \n   346→    // Check how many findings contain query terms\n   347→    const relevantFindings = findings.filter(f => {\n   348→      const content = f.content.toLowerCase();\n   349→      return queryTerms.some(term => content.includes(term));\n   350→    });\n   351→    \n   352→    const relevanceRatio = findings.length > 0 \n   353→      ? relevantFindings.length / findings.length \n   354→      : 0;\n   355→    \n   356→    return relevanceRatio * 100;\n   357→  }\n   358→\n   359→  private calculateSourceQuality(references: Reference[]): number {\n   360→    if (references.length === 0) return 0;\n   361→    \n   362→    // Factor in source count\n   363→    const countScore = Math.min(100, (references.length / this.thresholds.minimumSources) * 50);\n   364→    \n   365→    // Factor in source confidence\n   366→    const avgConfidence = references\n   367→      .map(r => r.metadata.confidence || 0.5)\n   368→      .reduce((sum, c) => sum + c, 0) / references.length;\n   369→    \n   370→    const confidenceScore = avgConfidence * 100;\n   371→    \n   372→    // Factor in source diversity (different domains)\n   373→    const uniqueDomains = new Set(\n   374→      references.map(r => new URL(r.metadata.url).hostname)\n   375→    );\n   376→    const diversityScore = Math.min(100, (uniqueDomains.size / Math.max(3, references.length * 0.5)) * 100);\n   377→    \n   378→    return (countScore + confidenceScore + diversityScore) / 3;\n   379→  }\n   380→\n   381→  private calculateDepth(\n   382→    findings: Array<{ content: string }>,\n   383→    references: Reference[]\n   384→  ): number {\n   385→    // Average content length as proxy for depth\n   386→    const avgContentLength = findings.length > 0\n   387→      ? findings.reduce((sum, f) => sum + f.content.length, 0) / findings.length\n   388→      : 0;\n   389→    \n   390→    const lengthScore = Math.min(100, (avgContentLength / 500) * 100);\n   391→    \n   392→    // Citation density (citations per finding)\n   393→    const citationDensity = findings.length > 0\n   394→      ? references.length / findings.length\n   395→      : 0;\n   396→    \n   397→    const citationScore = Math.min(100, citationDensity * 50);\n   398→    \n   399→    return (lengthScore + citationScore) / 2;\n   400→  }\n   401→\n   402→  private calculateCoherence(findings: Array<{ content: string }>): number {\n   403→    // Simple coherence check - no contradictions detected\n   404→    // In a real implementation, this would check for contradictions\n   405→    return 85; // Base coherence score\n   406→  }\n   407→\n   408→  private calculateAverageConfidence(\n   409→    findings: Array<{ confidence?: number }>\n   410→  ): number {\n   411→    const confidences = findings\n   412→      .map(f => f.confidence)\n   413→      .filter((c): c is number => c !== undefined);\n   414→    \n   415→    if (confidences.length === 0) return 0;\n   416→    \n   417→    return confidences.reduce((sum, c) => sum + c, 0) / confidences.length;\n   418→  }\n   419→\n   420→  private aggregateQualityDimensions(sections: SectionMetadata[]): QualityDimensions {\n   421→    if (sections.length === 0) {\n   422→      return {\n   423→        completeness: 0,\n   424→        accuracy: 0,\n   425→        relevance: 0,\n   426→        sourceQuality: 0,\n   427→        depth: 0,\n   428→        coherence: 0\n   429→      };\n   430→    }\n   431→    \n   432→    const dimensions: QualityDimensions = {\n   433→      completeness: 0,\n   434→      accuracy: 0,\n   435→      relevance: 0,\n   436→      sourceQuality: 0,\n   437→      depth: 0,\n   438→      coherence: 0\n   439→    };\n   440→    \n   441→    for (const section of sections) {\n   442→      for (const [key, value] of Object.entries(section.qualityScores)) {\n   443→        dimensions[key as keyof QualityDimensions] += value;\n   444→      }\n   445→    }\n   446→    \n   447→    // Average across sections\n   448→    for (const key of Object.keys(dimensions)) {\n   449→      dimensions[key as keyof QualityDimensions] /= sections.length;\n   450→    }\n   451→    \n   452→    return dimensions;\n   453→  }\n   454→\n   455→  private getPriority(gap: number): 'critical' | 'high' | 'medium' | 'low' {\n   456→    if (gap > 30) return 'critical';\n   457→    if (gap > 20) return 'high';\n   458→    if (gap > 10) return 'medium';\n   459→    return 'low';\n   460→  }\n   461→\n   462→  private getRecommendations(dimension: keyof QualityDimensions, score: number): string[] {\n   463→    const recommendations: Record<keyof QualityDimensions, string[]> = {\n   464→      completeness: [\n   465→        'Research additional aspects of the query',\n   466→        'Ensure all required topics are covered',\n   467→        'Add more comprehensive findings'\n   468→      ],\n   469→      accuracy: [\n   470→        'Verify information with additional sources',\n   471→        'Focus on high-confidence sources',\n   472→        'Cross-reference claims for validation'\n   473→      ],\n   474→      relevance: [\n   475→        'Focus research on core query terms',\n   476→        'Remove tangential information',\n   477→        'Ensure findings directly address the query'\n   478→      ],\n   479→      sourceQuality: [\n   480→        'Add more authoritative sources',\n   481→        'Diversify source types',\n   482→        'Increase total number of references'\n   483→      ],\n   484→      depth: [\n   485→        'Provide more detailed analysis',\n   486→        'Add supporting evidence for claims',\n   487→        'Expand on key concepts'\n   488→      ],\n   489→      coherence: [\n   490→        'Resolve contradictory information',\n   491→        'Ensure internal consistency',\n   492→        'Connect related findings'\n   493→      ]\n   494→    };\n   495→    \n   496→    return recommendations[dimension] || ['Improve ' + dimension];\n   497→  }\n   498→}\n   499→\n   500→// Export singleton instance\n   501→export const qualityMetrics = new QualityMetrics();\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Now let me examine the modified files to understand the integration:"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01EVcuGiNsfYcxHP5DXnQeAD",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/tools/webSearchTool.ts",
          "limit": 100
        }
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01FT6KyAtxGGNtR57Eu6hN1b",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/tools/extractLearningsTool.ts",
          "limit": 100
        }
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01EVcuGiNsfYcxHP5DXnQeAD",
        "type": "tool_result",
        "content": "     1→import { createTool } from '@mastra/core/tools';\n     2→import { z } from 'zod';\n     3→import Exa from 'exa-js';\n     4→import 'dotenv/config';\n     5→import { referenceManager } from '../storage/referenceManager';\n     6→\n     7→// Initialize Exa client\n     8→const exa = new Exa(process.env.EXA_API_KEY);\n     9→\n    10→export const webSearchTool = createTool({\n    11→  id: 'web-search',\n    12→  description: 'Search the web for information on a specific query and return summarized content',\n    13→  inputSchema: z.object({\n    14→    query: z.string().describe('The search query to run'),\n    15→  }),\n    16→  execute: async ({ context, mastra }) => {\n    17→    console.log('Executing web search tool');\n    18→    const { query } = context;\n    19→\n    20→    try {\n    21→      if (!process.env.EXA_API_KEY) {\n    22→        console.error('Error: EXA_API_KEY not found in environment variables');\n    23→        return { results: [], error: 'Missing API key' };\n    24→      }\n    25→\n    26→      console.log(`Searching web for: \"${query}\"`);\n    27→      const { results } = await exa.searchAndContents(query, {\n    28→        livecrawl: 'always',\n    29→        numResults: 2,\n    30→      });\n    31→\n    32→      if (!results || results.length === 0) {\n    33→        console.log('No search results found');\n    34→        return { results: [], error: 'No results found' };\n    35→      }\n    36→\n    37→      console.log(`Found ${results.length} search results, summarizing content...`);\n    38→\n    39→      // Get the summarization agent - fallback to no summarization if mastra is not available\n    40→      let summaryAgent = null;\n    41→      if (mastra) {\n    42→        try {\n    43→          summaryAgent = mastra.getAgent('webSummarizationAgent');\n    44→        } catch (e) {\n    45→          console.log('Warning: Could not get summarization agent, returning raw results');\n    46→        }\n    47→      }\n    48→\n    49→      // Process each result with summarization\n    50→      const processedResults = [];\n    51→      for (const result of results) {\n    52→        try {\n    53→          // Add reference to ReferenceManager\n    54→          const citationKey = referenceManager.addReference({\n    55→            url: result.url,\n    56→            title: result.title || '',\n    57→            snippet: result.text ? result.text.substring(0, 500) : undefined,\n    58→            content: result.text,\n    59→            accessedAt: new Date().toISOString(),\n    60→            sourceType: 'web',\n    61→            queryUsed: query,\n    62→            agentName: 'webSearchTool'\n    63→          });\n    64→\n    65→          // Skip if content is too short or missing\n    66→          if (!result.text || result.text.length < 100) {\n    67→            processedResults.push({\n    68→              title: result.title || '',\n    69→              url: result.url,\n    70→              content: result.text || 'No content available',\n    71→              citationKey\n    72→            });\n    73→            continue;\n    74→          }\n    75→\n    76→          // Summarize the content if agent is available\n    77→          if (summaryAgent) {\n    78→            const summaryResponse = await summaryAgent.generate([\n    79→              {\n    80→                role: 'user',\n    81→                content: `Please summarize the following web content for research query: \"${query}\"\n    82→\n    83→Title: ${result.title || 'No title'}\n    84→URL: ${result.url}\n    85→Content: ${result.text.substring(0, 8000)}...\n    86→\n    87→Provide a concise summary that captures the key information relevant to the research query.`,\n    88→              },\n    89→            ]);\n    90→\n    91→            processedResults.push({\n    92→              title: result.title || '',\n    93→              url: result.url,\n    94→              content: summaryResponse.text,\n    95→              citationKey\n    96→            });\n    97→\n    98→            console.log(`Summarized content for: ${result.title || result.url}`);\n    99→          } else {\n   100→            // No summarization agent available, use truncated content\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01FT6KyAtxGGNtR57Eu6hN1b",
        "type": "tool_result",
        "content": "     1→import { createTool } from '@mastra/core/tools';\n     2→import { z } from 'zod';\n     3→import { referenceManager } from '../storage/referenceManager';\n     4→\n     5→export const extractLearningsTool = createTool({\n     6→  id: 'extract-learnings',\n     7→  description: 'Extract key learnings and follow-up questions from a search result',\n     8→  inputSchema: z.object({\n     9→    query: z.string().describe('The original research query'),\n    10→    result: z\n    11→      .object({\n    12→        title: z.string(),\n    13→        url: z.string(),\n    14→        content: z.string(),\n    15→      })\n    16→      .describe('The search result to process'),\n    17→  }),\n    18→  execute: async ({ context }) => {\n    19→    try {\n    20→      const { query, result } = context;\n    21→\n    22→      // Direct implementation of learning extraction without agent dependency\n    23→      // Following Mastra best practices - tools should be self-contained\n    24→      \n    25→      // Extract key terms from the query for relevance matching\n    26→      const queryLower = query.toLowerCase();\n    27→      const queryTerms = queryLower\n    28→        .split(/[\\s,;]+/)\n    29→        .filter(term => term.length > 3)\n    30→        .filter(term => !['what', 'when', 'where', 'which', 'that', 'this', 'these', 'those', 'about', 'latest', 'recent'].includes(term));\n    31→\n    32→      // Split content into sentences for analysis\n    33→      const sentences = result.content\n    34→        .split(/[.!?]+/)\n    35→        .map(s => s.trim())\n    36→        .filter(s => s.length > 30); // Filter out short fragments\n    37→\n    38→      // Find the most relevant sentences that contain query terms\n    39→      const relevantSentences = sentences\n    40→        .filter(sentence => {\n    41→          const sentenceLower = sentence.toLowerCase();\n    42→          return queryTerms.some(term => sentenceLower.includes(term));\n    43→        })\n    44→        .slice(0, 3); // Take top 3 most relevant sentences\n    45→\n    46→      // Extract the key learning - combine most relevant sentences or use first substantial sentence\n    47→      let learning = '';\n    48→      let learningConfidence = 0.5; // Base confidence\n    49→      \n    50→      if (relevantSentences.length > 0) {\n    51→        learning = relevantSentences[0];\n    52→        // If the learning is too short, combine with next relevant sentence\n    53→        if (learning.length < 100 && relevantSentences.length > 1) {\n    54→          learning = `${relevantSentences[0]} ${relevantSentences[1]}`;\n    55→        }\n    56→        // Higher confidence when learning contains query terms\n    57→        learningConfidence = 0.7 + (0.1 * Math.min(3, relevantSentences.length));\n    58→      } else if (sentences.length > 0) {\n    59→        // Fallback to first substantial sentence if no query terms found\n    60→        learning = sentences[0];\n    61→        learningConfidence = 0.4; // Lower confidence for fallback\n    62→      } else {\n    63→        learning = result.title || 'Unable to extract specific learning from content';\n    64→        learningConfidence = 0.2; // Very low confidence\n    65→      }\n    66→\n    67→      // Add citation context to reference manager\n    68→      if (result.url) {\n    69→        referenceManager.addCitationContext(\n    70→          result.url,\n    71→          learning,\n    72→          learningConfidence,\n    73→          'learningExtraction'\n    74→        );\n    75→      }\n    76→\n    77→      // Generate a follow-up question based on the extracted learning\n    78→      let followUpQuestion = '';\n    79→      \n    80→      // Identify key concepts in the learning for follow-up\n    81→      const concepts = learning\n    82→        .match(/\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g) // Find proper nouns/concepts\n    83→        ?.filter(c => c.length > 3) || [];\n    84→      \n    85→      if (concepts.length > 0) {\n    86→        // Generate follow-up based on identified concepts\n    87→        const concept = concepts[0];\n    88→        if (queryLower.includes('how')) {\n    89→          followUpQuestion = `What are the specific implementation details of ${concept}?`;\n    90→        } else if (queryLower.includes('what')) {\n    91→          followUpQuestion = `How does ${concept} compare to alternative approaches?`;\n    92→        } else if (queryLower.includes('breakthrough') || queryLower.includes('advance')) {\n    93→          followUpQuestion = `What are the practical applications of ${concept}?`;\n    94→        } else {\n    95→          followUpQuestion = `What are the implications and future developments of ${concept}?`;\n    96→        }\n    97→      } else {\n    98→        // Generic follow-up based on query type\n    99→        if (queryLower.includes('quantum')) {\n   100→          followUpQuestion = 'What are the practical applications and timeline for commercial deployment?';\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me examine the modified agents and network integration:"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01A9jFdQQEBNk22y94sAerZj",
        "name": "Grep",
        "input": {
          "pattern": "referenceManager|qualityMetrics",
          "path": "src/mastra",
          "glob": "**/*.ts",
          "output_mode": "files_with_matches"
        }
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01A9jFdQQEBNk22y94sAerZj",
        "type": "tool_result",
        "content": "Found 8 files\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/storage/index.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/networks/streamingResearchNetwork.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/agents/qualityAssessmentAgent.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/agents/reportAgent.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/storage/qualityMetrics.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/tools/extractLearningsTool.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/tools/webSearchTool.ts\n/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/storage/referenceManager.ts"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_012JyzRoR2D52TrqwduMoYFa",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/agents/reportAgent.ts",
          "limit": 150
        }
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01YPpdjfUKiGJfGUHnuNiNe1",
        "name": "Read",
        "input": {
          "file_path": "/mnt/c/Users/caleb/Desktop/GithubProjects/deepfield/src/mastra/agents/qualityAssessmentAgent.ts",
          "limit": 100
        }
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_012JyzRoR2D52TrqwduMoYFa",
        "type": "tool_result",
        "content": "     1→import { Agent } from '@mastra/core/agent';\n     2→import { openai } from '@ai-sdk/openai';\n     3→import { referenceManager } from '../storage/referenceManager';\n     4→import { Models } from '../config';\n     5→\n     6→const reportModel = openai(Models.small);\n     7→\n     8→export const reportAgent = new Agent({\n     9→  name: 'Report Agent',\n    10→  instructions: `You are an expert researcher. Today is ${new Date().toISOString()}. Follow these instructions when responding:\n    11→  - You may be asked to research subjects that are after your knowledge cutoff, assume the user is right when presented with news.\n    12→  - The user is a highly experienced analyst, no need to simplify it, be as detailed as possible and make sure your response is correct.\n    13→  - Be highly organized.\n    14→  - Suggest solutions that I didn't think about.\n    15→  - Be proactive and anticipate my needs.\n    16→  - Treat me as an expert in all subject matter.\n    17→  - Mistakes erode my trust, so be accurate and thorough.\n    18→  - Provide detailed explanations, I'm comfortable with lots of detail.\n    19→  - Value good arguments over authorities, the source is irrelevant.\n    20→  - Consider new technologies and contrarian ideas, not just the conventional wisdom.\n    21→  - You may use high levels of speculation or prediction, just flag it for me.\n    22→  - Use Markdown formatting.\n    23→\n    24→  CRITICAL CITATION REQUIREMENTS:\n    25→  - When referencing any source or making claims based on research data, include inline citations using the format [1], [2], etc.\n    26→  - Each citation key corresponds to a specific source URL that will be provided\n    27→  - Use citations throughout the text to support statements, not just at the end of paragraphs\n    28→  - Multiple citations can be used together when multiple sources support a claim [1][3][5]\n    29→  - ALWAYS include a \"References\" section at the end of the report listing all cited sources\n    30→\n    31→  Your task is to generate comprehensive reports based on research data that includes:\n    32→  - Search queries used\n    33→  - Relevant search results with their citation keys\n    34→  - Key learnings extracted from those results\n    35→  - Follow-up questions identified\n    36→  - Source URLs and their corresponding citation keys\n    37→\n    38→  Structure your reports with:\n    39→  1. Clear sections and headings\n    40→  2. Inline citations for all claims and findings\n    41→  3. Synthesis of information into a cohesive narrative\n    42→  4. A complete References section at the end\n    43→\n    44→  Example of proper citation usage:\n    45→  \"Recent breakthroughs in quantum computing [1] have shown promise for practical applications [2][3], \n    46→  particularly in drug discovery [4] and cryptography [1][5].\"`,\n    47→  model: reportModel,\n    48→});\n    49→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "user",
    "content": [
      {
        "tool_use_id": "toolu_01YPpdjfUKiGJfGUHnuNiNe1",
        "type": "tool_result",
        "content": "     1→import { Agent } from '@mastra/core/agent';\n     2→import { openai } from '@ai-sdk/openai';\n     3→import { z } from 'zod';\n     4→import { Models } from '../config';\n     5→import { qualityMetrics } from '../storage/qualityMetrics';\n     6→import { referenceManager } from '../storage/referenceManager';\n     7→\n     8→const mainModel = openai(Models.small);\n     9→\n    10→export const qualityAssessmentAgent = new Agent({\n    11→  name: 'Quality Assessment Agent',\n    12→  instructions: `You are a quality assessment agent responsible for evaluating research completeness and determining if research meets quality standards.\n    13→  \n    14→  Your responsibilities:\n    15→  1. Evaluate research results against predefined quality criteria\n    16→  2. Check for comprehensive topic coverage\n    17→  3. Assess source credibility and diversity\n    18→  4. Determine if research depth is sufficient\n    19→  5. Make autonomous approval decisions\n    20→  \n    21→  When evaluating research:\n    22→  - Compare actual results against required topic coverage\n    23→  - Count and validate sources meet minimum requirements\n    24→  - Check for information gaps or missing perspectives\n    25→  - Assess whether the depth level matches requirements\n    26→  - Identify specific areas needing improvement if insufficient\n    27→  \n    28→  You replace human approval by making intelligent decisions about:\n    29→  - Whether research meets quality thresholds\n    30→  - If refinement is needed and what specific gaps exist\n    31→  - When diminishing returns make further research unnecessary\n    32→  - Overall research sufficiency for the given query\n    33→  \n    34→  Be strict but fair - approve research that genuinely meets criteria, but identify specific gaps when improvement is needed.`,\n    35→  model: mainModel,\n    36→});\n    37→\n    38→export const assessResearchQuality = async (\n    39→  researchData: any,\n    40→  qualityCriteria: {\n    41→    minimumSources: number;\n    42→    requiredTopicCoverage: string[];\n    43→    depthLevel: 'surface' | 'moderate' | 'deep';\n    44→    originalQuery?: string;\n    45→  }\n    46→) => {\n    47→  // Use multi-dimensional quality metrics\n    48→  const findings = Array.isArray(researchData.learnings) \n    49→    ? researchData.learnings.map((l: any) => ({\n    50→        content: typeof l === 'string' ? l : l.learning || l.content || '',\n    51→        confidence: l.confidence,\n    52→        sources: l.sources\n    53→      }))\n    54→    : [];\n    55→  \n    56→  const originalQuery = qualityCriteria.originalQuery || researchData.query || '';\n    57→  \n    58→  // Calculate quality dimensions\n    59→  const qualityDimensions = qualityMetrics.assessResearchQuality(\n    60→    findings,\n    61→    originalQuery,\n    62→    qualityCriteria.requiredTopicCoverage\n    63→  );\n    64→  \n    65→  const overallScore = qualityMetrics.calculateOverallScore(qualityDimensions);\n    66→  const meetsThresholds = qualityMetrics.meetsQualityThresholds(qualityDimensions);\n    67→  const improvements = qualityMetrics.generateImprovementRecommendations(qualityDimensions);\n    68→  \n    69→  // Get reference statistics\n    70→  const refStats = referenceManager.getStatistics();\n    71→  \n    72→  // Use agent for additional semantic analysis\n    73→  const response = await qualityAssessmentAgent.generate(\n    74→    [\n    75→      {\n    76→        role: 'user',\n    77→        content: `Evaluate this research against the quality criteria:\n    78→        \n    79→        Research Data:\n    80→        ${JSON.stringify(researchData, null, 2)}\n    81→        \n    82→        Quality Criteria:\n    83→        - Minimum Sources: ${qualityCriteria.minimumSources}\n    84→        - Required Topics: ${qualityCriteria.requiredTopicCoverage.join(', ')}\n    85→        - Depth Level: ${qualityCriteria.depthLevel}\n    86→        \n    87→        Quality Metrics Assessment:\n    88→        - Completeness: ${qualityDimensions.completeness.toFixed(1)}%\n    89→        - Accuracy: ${qualityDimensions.accuracy.toFixed(1)}%\n    90→        - Relevance: ${qualityDimensions.relevance.toFixed(1)}%\n    91→        - Source Quality: ${qualityDimensions.sourceQuality.toFixed(1)}%\n    92→        - Depth: ${qualityDimensions.depth.toFixed(1)}%\n    93→        - Coherence: ${qualityDimensions.coherence.toFixed(1)}%\n    94→        - Overall Score: ${overallScore.toFixed(1)}%\n    95→        \n    96→        Reference Statistics:\n    97→        - Total References: ${refStats.totalReferences}\n    98→        - High Confidence References: ${refStats.referencesWithHighConfidence}\n    99→        - Average Confidence: ${refStats.averageConfidence.toFixed(2)}\n   100→        \n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "text",
        "text": "Let me check the streaming network integration:"
      }
    ]
  },
  {
    "role": "assistant",
    "content": [
      {
        "type": "tool_use",
        "id": "toolu_01C5MnSDPxky8t58AgRFqjvE",
        "name": "Grep",
        "input": {
          "pattern": "referenceManager|qualityMetrics",
          "path": "src/mastra/networks/streamingResearchNetwork.ts",
          "output_mode": "content",
          "-B": 3,
          "-A": 3
        }
      }
    ]
  }
]